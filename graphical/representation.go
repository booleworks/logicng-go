package graphical

// Node represents a node in the graphical representation.
type Node struct {
	id       string
	label    string
	style    *NodeStyle
	terminal bool
}

// NewNode generates a new graphical node with the given ID and label as
// string, the given node style and an optional flag indicating whether the
// node is a terminal node (in a tree) or not.
func NewNode(id, label string, style *NodeStyle, terminal ...bool) *Node {
	term := false
	if terminal != nil {
		term = terminal[0]
	}
	return &Node{id, label, style, term}
}

// Edge represents an edge connecting two nodes in the graphical
// representation.
type Edge struct {
	source      *Node
	destination *Node
	style       *EdgeStyle
	label       string
}

// NewEdge generates a new edge between the two given source and destintion
// node with the given style and an optional label for the edge.
func NewEdge(source, destination *Node, style *EdgeStyle, label ...string) *Edge {
	lbl := ""
	if label != nil {
		lbl = label[0]
	}
	return &Edge{source, destination, style, lbl}
}

// A Representation is the internal data model for a graphical representation
// of a graph or tree.  It can be generated by different graph generators and
// then be written as Dot or Mermaid.js file.
type Representation struct {
	alignTerminals bool
	directed       bool
	background     Color
	nodes          []*Node
	edges          []*Edge
}

// NewGraphicalRepresentation generates a new empty graphical representation.
// The flag alignTerminals indicates whether in a tree all terminal nodes
// should be aligned on the same level.  The flag directed indicates if the
// graph is directed (edges have a direction).  The parameter background is
// used as background color.
func NewGraphicalRepresentation(alignTerminals, directed bool, background Color) *Representation {
	return &Representation{alignTerminals, directed, background, []*Node{}, []*Edge{}}
}

// Nodes returns all nodes of the representation.
func (r *Representation) Nodes() []*Node {
	return r.nodes
}

// AddNode adds the given nodes to the representation.
func (r *Representation) AddNode(node ...*Node) {
	r.nodes = append(r.nodes, node...)
}

// AddEdge adds the given edges to the representation.
func (r *Representation) AddEdge(edge ...*Edge) {
	r.edges = append(r.edges, edge...)
}

// TerminalNodes returns the terminal nodes (nodes without outgoing edges) of
// the representation.
func (r *Representation) TerminalNodes() []*Node {
	result := make([]*Node, 0)
	for _, node := range r.nodes {
		if node.terminal {
			result = append(result, node)
		}
	}
	return result
}

// NonTerminalNodes returns the non-terminal nodes (nodes with outgoing edges)
// of the representation.
func (r *Representation) NonTerminalNodes() []*Node {
	result := make([]*Node, 0)
	for _, node := range r.nodes {
		if !node.terminal {
			result = append(result, node)
		}
	}
	return result
}
